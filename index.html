<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>2048</title>

<style>
:root{
  --bg:#faf8ef;
  --board:#bbada0;
  --empty:#cdc1b4;
  --text:#776e65;
  --light:#f9f6f2;

  --pad:10px;
  --gap:10px;
  --radius:12px;

  /* Animation (closer to original) */
  --moveDur: 180ms;
  --ease: cubic-bezier(.2,.8,.2,1);
  --spawnDur: 220ms;
  --mergeDur: 220ms;
}

*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  overscroll-behavior:none;
  background:var(--bg);
  font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,system-ui,sans-serif;
}
body{display:flex;justify-content:center}

.wrap{width:min(520px,100%);padding:16px}

.header{display:flex;justify-content:space-between;align-items:flex-end;gap:12px;flex-wrap:wrap}
h1{margin:0;font-size:48px;color:var(--text);letter-spacing:-1px}

.scoreRow{display:flex;gap:10px}
.scorebox{
  background:var(--board);
  color:var(--light);
  padding:8px 12px;
  border-radius:10px;
  text-align:center;
  min-width:92px;
}
.scorebox small{display:block;font-size:11px;font-weight:800;letter-spacing:.5px;opacity:.9}
.scorebox span{display:block;font-weight:900;font-size:18px;margin-top:2px}

.controls{margin:10px 0 12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
button{
  background:#8f7a66;border:none;color:#fff;
  padding:10px 14px;border-radius:10px;font-weight:900;
}
button:active{transform:translateY(1px)}

.board{
  background:var(--board);
  padding:var(--pad);
  border-radius:var(--radius);
  position:relative;
  width:100%;
  aspect-ratio:1/1;
  touch-action:none;
  user-select:none;
}

.grid{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  grid-template-rows:repeat(4,1fr);
  gap:var(--gap);
  width:100%;
  height:100%;
}

.cell{background:var(--empty);border-radius:12px}

/* tile layer shares SAME box as grid (inside padding) */
.tile-layer{
  position:absolute;
  inset:var(--pad);
  pointer-events:none;
}

.tile{
  position:absolute;
  transition:transform var(--moveDur) var(--ease);
  will-change:transform;
}
.tile.noanim{ transition:none !important; }

.tile-inner{
  width:100%;
  height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  border-radius:12px;
  transform:scale(1);
}

/* Spawn + merge animations */
@keyframes popIn {
  0%   { transform:scale(0); }
  55%  { transform:scale(1.08); }
  100% { transform:scale(1); }
}
@keyframes popMerge {
  0%   { transform:scale(1); }
  40%  { transform:scale(1.12); }
  100% { transform:scale(1); }
}
.tile.spawn .tile-inner{ animation: popIn var(--spawnDur) var(--ease) both; }
.tile.merge .tile-inner{ animation: popMerge var(--mergeDur) var(--ease) both; }

/* colors */
.v2{background:#eee4da;color:var(--text)}
.v4{background:#ede0c8;color:var(--text)}
.v8{background:#f2b179;color:white}
.v16{background:#f59563;color:white}
.v32{background:#f67c5f;color:white}
.v64{background:#f65e3b;color:white}
.v128{background:#edcf72;color:white}
.v256{background:#edcc61;color:white}
.v512{background:#edc850;color:white}
.v1024{background:#edc53f;color:white}
.v2048{background:#edc22e;color:white}

@media (prefers-reduced-motion: reduce){
  :root{ --moveDur: 1ms; --spawnDur: 1ms; --mergeDur: 1ms; }
  .tile-inner{ animation:none !important; }
}
</style>
</head>

<body>
<div class="wrap">
  <div class="header">
    <h1>2048</h1>
    <div class="scoreRow">
      <div class="scorebox"><small>SCORE</small><span id="score">0</span></div>
      <div class="scorebox"><small>BEST</small><span id="best">0</span></div>
    </div>
  </div>

  <div class="controls">
    <button id="newBtn">Neu</button>
    <button id="undoBtn">Undo</button>
  </div>

  <div class="board" id="board">
    <div class="grid" id="grid" aria-hidden="true">
      <div class="cell" data-r="0" data-c="0"></div><div class="cell" data-r="0" data-c="1"></div><div class="cell" data-r="0" data-c="2"></div><div class="cell" data-r="0" data-c="3"></div>
      <div class="cell" data-r="1" data-c="0"></div><div class="cell" data-r="1" data-c="1"></div><div class="cell" data-r="1" data-c="2"></div><div class="cell" data-r="1" data-c="3"></div>
      <div class="cell" data-r="2" data-c="0"></div><div class="cell" data-r="2" data-c="1"></div><div class="cell" data-r="2" data-c="2"></div><div class="cell" data-r="2" data-c="3"></div>
      <div class="cell" data-r="3" data-c="0"></div><div class="cell" data-r="3" data-c="1"></div><div class="cell" data-r="3" data-c="2"></div><div class="cell" data-r="3" data-c="3"></div>
    </div>
    <div class="tile-layer" id="tiles"></div>
  </div>
</div>

<script>
(() => {
  const SIZE = 4;
  const MOVE_MS = 180; // keep in sync with --moveDur

  const boardEl = document.getElementById('board');
  const gridEl  = document.getElementById('grid');
  const layer   = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const newBtn  = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');

  let best = Number(localStorage.getItem('best2048') || 0) || 0;
  bestEl.textContent = best;

  // Game state with persistent tile objects (enables animations)
  let score = 0;
  let nextId = 1;
  let cells = Array.from({length: SIZE}, () => Array(SIZE).fill(null)); // tile or null
  let tiles = new Map(); // id -> {id,value,r,c,el}
  let busy = false;

  let prev = null; // {score, nextId, cellsSnapshot, tilesSnapshot}

  // Measure real background cell positions => perfect alignment on all devices
  let cellPos = Array.from({length: SIZE}, () => Array.from({length: SIZE}, () => ({x:0,y:0,w:0,h:0})));
  function measureCells(){
    const gridRect = gridEl.getBoundingClientRect();
    gridEl.querySelectorAll('.cell').forEach(cell => {
      const r = Number(cell.dataset.r), c = Number(cell.dataset.c);
      const rect = cell.getBoundingClientRect();
      cellPos[r][c] = { x: rect.left - gridRect.left, y: rect.top - gridRect.top, w: rect.width, h: rect.height };
    });
  }

  function fontSizeFor(value, w){
    const d = String(value).length;
    if (d <= 2) return w / 2.4;
    if (d === 3) return w / 2.8;
    if (d === 4) return w / 3.25;
    return w / 3.7;
  }

  function mkTile(value, r, c, {spawn=false}={}){
    const id = nextId++;
    const p = cellPos[r][c];

    const tile = document.createElement('div');
    tile.className = 'tile noanim';
    tile.style.width = p.w + 'px';
    tile.style.height = p.h + 'px';

    const inner = document.createElement('div');
    inner.className = 'tile-inner v' + value;
    inner.textContent = value;
    inner.style.fontSize = fontSizeFor(value, p.w) + 'px';
    tile.appendChild(inner);

    // place immediately without anim, then enable transitions next frame
    tile.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
    layer.appendChild(tile);

    const obj = {id, value, r, c, el: tile};
    tiles.set(id, obj);
    cells[r][c] = obj;

    requestAnimationFrame(() => {
      tile.classList.remove('noanim');
      if (spawn) {
        tile.classList.add('spawn');
        // remove class after animation so it can re-trigger later if needed
        setTimeout(() => tile.classList.remove('spawn'), 260);
      }
    });

    return obj;
  }

  function setTileValue(tileObj, newValue, {merge=false}={}){
    tileObj.value = newValue;
    const inner = tileObj.el.firstElementChild;
    inner.className = 'tile-inner v' + newValue;
    inner.textContent = newValue;
    const p = cellPos[tileObj.r][tileObj.c];
    inner.style.fontSize = fontSizeFor(newValue, p.w) + 'px';
    if (merge){
      tileObj.el.classList.add('merge');
      setTimeout(() => tileObj.el.classList.remove('merge'), 260);
    }
  }

  function moveTileTo(tileObj, r, c){
    // update logical position now; CSS transition animates to new transform
    cells[tileObj.r][tileObj.c] = null;
    tileObj.r = r; tileObj.c = c;
    cells[r][c] = tileObj;

    const p = cellPos[r][c];
    tileObj.el.style.width = p.w + 'px';
    tileObj.el.style.height = p.h + 'px';
    tileObj.el.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
  }

  function saveUndo(){
    // snapshot minimal state
    const cellsSnap = cells.map(row => row.map(t => t ? t.id : null));
    const tilesSnap = Array.from(tiles.values()).map(t => ({id:t.id, value:t.value, r:t.r, c:t.c}));
    prev = {score, best, nextId, cellsSnap, tilesSnap};
  }

  function undo(){
    if (!prev || busy) return;
    // clear DOM
    layer.innerHTML = '';
    tiles.clear();
    cells = Array.from({length: SIZE}, () => Array(SIZE).fill(null));

    score = prev.score;
    nextId = prev.nextId;
    // restore tiles
    measureCells();
    prev.tilesSnap.forEach(t => {
      const p = cellPos[t.r][t.c];
      const el = document.createElement('div');
      el.className = 'tile noanim';
      el.style.width = p.w + 'px';
      el.style.height = p.h + 'px';
      el.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
      const inner = document.createElement('div');
      inner.className = 'tile-inner v' + t.value;
      inner.textContent = t.value;
      inner.style.fontSize = fontSizeFor(t.value, p.w) + 'px';
      el.appendChild(inner);
      layer.appendChild(el);
      const obj = {id:t.id, value:t.value, r:t.r, c:t.c, el};
      tiles.set(t.id, obj);
      cells[t.r][t.c] = obj;
    });
    requestAnimationFrame(() => {
      tiles.forEach(t => t.el.classList.remove('noanim'));
    });

    scoreEl.textContent = score;
    bestEl.textContent = best;
    prev = null;
  }

  function updateScore(){
    scoreEl.textContent = score;
    if (score > best){
      best = score;
      localStorage.setItem('best2048', String(best));
      bestEl.textContent = best;
    }
  }

  function spawnOne(){
    const empty = [];
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!cells[r][c]) empty.push([r,c]);
    if (!empty.length) return false;
    const [r,c] = empty[(Math.random()*empty.length)|0];
    const v = Math.random() < 0.9 ? 2 : 4;
    mkTile(v, r, c, {spawn:true});
    return true;
  }

  function canMove(){
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!cells[r][c]) return true;
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const v = cells[r][c].value;
        if (r+1<SIZE && cells[r+1][c].value === v) return true;
        if (c+1<SIZE && cells[r][c+1].value === v) return true;
      }
    }
    return false;
  }

  function lineGet(r,c, dr,dc){
    const arr = [];
    for (let i=0;i<SIZE;i++){
      arr.push({r: r + dr*i, c: c + dc*i});
    }
    return arr;
  }

  // Core move with persistent tiles + merge after movement
  function move(dir){
    if (busy) return;
    measureCells();

    const d = dir;
    let dr=0, dc=0;
    if (d==='L') dc=-1;
    if (d==='R') dc= 1;
    if (d==='U') dr=-1;
    if (d==='D') dr= 1;

    // prepare traversal lines
    const lines = [];
    if (d==='L' || d==='R'){
      for (let r=0;r<SIZE;r++){
        lines.push(lineGet(r, d==='L'?0:SIZE-1, 0, d==='L'?1:-1));
      }
    } else {
      for (let c=0;c<SIZE;c++){
        lines.push(lineGet(d==='U'?0:SIZE-1, c, d==='U'?1:-1, 0));
      }
    }

    saveUndo();

    // Plan: for each line, slide tiles to compact, mark merges.
    // We will move tiles immediately (CSS animates), then after MOVE_MS apply merges (value update + remove absorbed).
    const merges = []; // {keeper, absorbed, newValue}
    let movedAny = false;

    // We'll build a new cell occupancy map using ids but reuse tiles.
    // Start by clearing cells references; we will repopulate with moveTileTo.
    const oldTiles = Array.from(tiles.values());
    cells = Array.from({length: SIZE}, () => Array(SIZE).fill(null));

    // helper to place tile without anim disabling
    function placeTile(tileObj, r, c){
      // movedAny if position changed
      if (tileObj.r !== r || tileObj.c !== c) movedAny = true;
      tileObj.r = r; tileObj.c = c;
      cells[r][c] = tileObj;
    }

    // We'll compute per line in order and decide targets,
    // but we must keep original tileObj references and also animate them to targets.
    for (const coords of lines){
      // collect tiles in this line in travel order
      const lineTiles = [];
      for (const p of coords){
        // find tile from oldTiles by previous coordinates
        const t = oldTiles.find(x => x.r===p.r && x.c===p.c);
        if (t) lineTiles.push(t);
      }

      // compress/merge
      let write = 0;
      let last = null;
      let lastMerged = false;

      for (const t of lineTiles){
        if (!last){
          last = t;
          lastMerged = false;
          const target = coords[write++];
          placeTile(t, target.r, target.c);
        } else if (!lastMerged && last.value === t.value){
          // merge into last (keeper = last), absorbed = t
          const target = coords[write-1];
          // keeper stays at coords[write-1]; absorbed also moves to same target
          placeTile(t, target.r, target.c);
          merges.push({keeperId: last.id, absorbedId: t.id, newValue: last.value*2, r: target.r, c: target.c});
          lastMerged = true;
          movedAny = true; // merge implies movement/animation
        } else {
          last = t;
          lastMerged = false;
          const target = coords[write++];
          placeTile(t, target.r, target.c);
        }
      }

      // fill rest empty already by default
    }

    if (!movedAny){
      // restore previous snapshot availability (undo should not activate)
      prev = null;
      // restore cells to oldTiles placements
      cells = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
      oldTiles.forEach(t => { cells[t.r][t.c] = t; });
      return;
    }

    busy = true;

    // Animate: move every tile element to its new measured cell position.
    // Use the measured cellPos. Important: some tiles may now share a cell temporarily (merge).
    for (const t of oldTiles){
      const p = cellPos[t.r][t.c];
      t.el.style.width = p.w + 'px';
      t.el.style.height = p.h + 'px';
      t.el.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
      // update font size after move end when value might change
    }

    // After movement ends, resolve merges: remove absorbed, update keeper value + bounce
    setTimeout(() => {
      // Apply merges
      for (const m of merges){
        const keeper = tiles.get(m.keeperId);
        const absorbed = tiles.get(m.absorbedId);
        if (!keeper || !absorbed) continue;

        // Remove absorbed tile element
        absorbed.el.remove();
        tiles.delete(absorbed.id);

        // Ensure keeper is at merge cell (it should be)
        keeper.r = m.r; keeper.c = m.c;
        // Update keeper value + merge pop
        setTileValue(keeper, m.newValue, {merge:true});
      }

      // Rebuild cells map again clean (no double-occupancy)
      const newCells = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
      tiles.forEach(t => { newCells[t.r][t.c] = t; });
      cells = newCells;

      updateScore();

      // Spawn new tile (with pop)
      measureCells();
      spawnOne();

      // Allow next input after a short extra frame
      setTimeout(() => { busy = false; }, 20);
    }, MOVE_MS + 10);
  }

  function newGame(){
    busy = false;
    prev = null;
    score = 0;
    nextId = 1;
    layer.innerHTML = '';
    tiles.clear();
    cells = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
    measureCells();
    spawnOne();
    spawnOne();
    updateScore();
  }

  // Touch: block scroll and detect swipe
  let start = null;
  boardEl.addEventListener('touchstart', (e) => {
    if (e.touches.length !== 1 || busy) return;
    start = {x: e.touches[0].clientX, y: e.touches[0].clientY};
  }, {passive:true});
  boardEl.addEventListener('touchmove', (e) => { e.preventDefault(); }, {passive:false});
  boardEl.addEventListener('touchend', (e) => {
    if (!start || busy) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - start.x;
    const dy = t.clientY - start.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const TH = 28;
    if (Math.max(adx, ady) < TH) { start = null; return; }
    if (adx > ady) move(dx > 0 ? 'R' : 'L');
    else move(dy > 0 ? 'D' : 'U');
    start = null;
  }, {passive:true});

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (busy) return;
    if (e.key === 'ArrowLeft')  { e.preventDefault(); move('L'); }
    if (e.key === 'ArrowRight') { e.preventDefault(); move('R'); }
    if (e.key === 'ArrowUp')    { e.preventDefault(); move('U'); }
    if (e.key === 'ArrowDown')  { e.preventDefault(); move('D'); }
  }, {passive:false});

  newBtn.addEventListener('click', newGame);
  undoBtn.addEventListener('click', undo);

  window.addEventListener('resize', () => {
    measureCells();
    // update all tile transforms to new measured positions (no animation jerk)
    tiles.forEach(t => {
      const p = cellPos[t.r][t.c];
      t.el.classList.add('noanim');
      t.el.style.width = p.w + 'px';
      t.el.style.height = p.h + 'px';
      t.el.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
      const inner = t.el.firstElementChild;
      inner.style.fontSize = fontSizeFor(t.value, p.w) + 'px';
      requestAnimationFrame(() => t.el.classList.remove('noanim'));
    });
  }, {passive:true});

  window.addEventListener('orientationchange', () => setTimeout(() => {
    measureCells();
    tiles.forEach(t => {
      const p = cellPos[t.r][t.c];
      t.el.classList.add('noanim');
      t.el.style.width = p.w + 'px';
      t.el.style.height = p.h + 'px';
      t.el.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;
      const inner = t.el.firstElementChild;
      inner.style.fontSize = fontSizeFor(t.value, p.w) + 'px';
      requestAnimationFrame(() => t.el.classList.remove('noanim'));
    });
  }, 60), {passive:true});

  // Init
  measureCells();
  newGame();
})();
</script>
</body>
</html>
