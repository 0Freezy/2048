<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>2048</title>

<style>
:root{
  --bg:#faf8ef;
  --board:#bbada0;
  --empty:#cdc1b4;
  --text:#776e65;
  --light:#f9f6f2;

  --pad:10px;   /* board padding */
  --gap:10px;   /* grid gap */
  --radius:12px;
  --cell:60px;  /* computed in JS */
}

*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{
  margin:0;
  height:100%;
  overflow:hidden;              /* stop page scroll */
  overscroll-behavior:none;     /* stop rubber-band */
  background:var(--bg);
  font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;
}
body{display:flex;justify-content:center;}

.wrap{width:min(520px,100%);padding:16px}

h1{margin:0;font-size:48px;color:var(--text)}
.header{display:flex;justify-content:space-between;align-items:flex-end;gap:12px}

.scorebox{
  background:var(--board);
  color:var(--light);
  padding:8px 12px;
  border-radius:10px;
  text-align:center;
  min-width:92px;
}
.scorebox small{display:block;font-size:11px;font-weight:800;letter-spacing:.5px;opacity:.9}
.scorebox span{display:block;font-weight:900;font-size:18px;margin-top:2px}

.controls{margin:10px 0;display:flex;gap:10px;align-items:center}
button{
  background:#8f7a66;border:none;color:#fff;
  padding:10px 14px;border-radius:10px;font-weight:900;
}

.board{
  background:var(--board);
  padding:var(--pad);
  border-radius:var(--radius);
  position:relative;
  width:100%;
  aspect-ratio:1/1;
  touch-action:none;            /* stop browser gestures */
  user-select:none;
}

.grid{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  grid-template-rows:repeat(4,1fr);
  gap:var(--gap);
  width:100%;
  height:100%;
}

.cell{background:var(--empty);border-radius:12px}

/* Absolute tile layer exactly aligned to the grid content box */
.tile-layer{
  position:absolute;
  inset:var(--pad);
  width:calc(100% - (2 * var(--pad)));
  height:calc(100% - (2 * var(--pad)));
  pointer-events:none;
}

.tile{
  position:absolute;
  width:var(--cell);
  height:var(--cell);
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  border-radius:12px;
  transition:transform .12s ease-in-out;
  will-change:transform;
}

/* colors */
.v2{background:#eee4da;color:var(--text)}
.v4{background:#ede0c8;color:var(--text)}
.v8{background:#f2b179;color:white}
.v16{background:#f59563;color:white}
.v32{background:#f67c5f;color:white}
.v64{background:#f65e3b;color:white}
.v128{background:#edcf72;color:white}
.v256{background:#edcc61;color:white}
.v512{background:#edc850;color:white}
.v1024{background:#edc53f;color:white}
.v2048{background:#edc22e;color:white}

/* font size by digits */
.tile[data-d="1"], .tile[data-d="2"]{font-size:calc(var(--cell) / 2.4)}
.tile[data-d="3"]{font-size:calc(var(--cell) / 2.8)}
.tile[data-d="4"]{font-size:calc(var(--cell) / 3.2)}
.tile[data-d="5"]{font-size:calc(var(--cell) / 3.7)}
</style>
</head>

<body>
<div class="wrap">
  <div class="header">
    <h1>2048</h1>
    <div style="display:flex;gap:10px">
      <div class="scorebox"><small>SCORE</small><span id="score">0</span></div>
      <div class="scorebox"><small>BEST</small><span id="best">0</span></div>
    </div>
  </div>

  <div class="controls">
    <button id="newBtn">Neu</button>
    <button id="undoBtn">Undo</button>
  </div>

  <div class="board" id="board">
    <div class="grid" aria-hidden="true">
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    </div>
    <div class="tile-layer" id="tiles"></div>
  </div>
</div>

<script>
(() => {
  const SIZE = 4;
  const GAP = 10;  // must match --gap
  const boardEl = document.getElementById('board');
  const layer = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const newBtn  = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');

  let grid, score = 0;
  let best = Number(localStorage.getItem('best2048') || 0) || 0;
  bestEl.textContent = best;

  let prev = null; // {grid, score}
  function cloneGrid(g){ return g.map(r => r.slice()); }

  function computeCell() {
    const w = layer.clientWidth; // already excludes board padding (inset)
    const cell = Math.floor((w - GAP * (SIZE - 1)) / SIZE);
    document.documentElement.style.setProperty('--cell', cell + 'px');
    return cell;
  }

  function spawn() {
    const empty = [];
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) empty.push([r,c]);
    if (!empty.length) return false;
    const [r,c] = empty[(Math.random() * empty.length) | 0];
    grid[r][c] = Math.random() < 0.9 ? 2 : 4;
    return true;
  }

  function render() {
    const cell = computeCell();
    layer.innerHTML = '';

    scoreEl.textContent = score;
    if (score > best) {
      best = score;
      localStorage.setItem('best2048', String(best));
      bestEl.textContent = best;
    }

    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const v = grid[r][c];
        if (!v) continue;
        const t = document.createElement('div');
        t.className = 'tile v' + v;
        t.textContent = v;
        t.dataset.d = String(String(v).length);
        const x = c * (cell + GAP);
        const y = r * (cell + GAP);
        t.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        layer.appendChild(t);
      }
    }
  }

  function canMove() {
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) return true;
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const v = grid[r][c];
        if (r+1<SIZE && grid[r+1][c] === v) return true;
        if (c+1<SIZE && grid[r][c+1] === v) return true;
      }
    }
    return false;
  }

  function move(dr, dc) {
    prev = { grid: cloneGrid(grid), score };

    let moved = false;
    const merged = Array.from({length: SIZE}, () => Array(SIZE).fill(false));

    const rStart = dr > 0 ? SIZE-1 : 0;
    const rEnd   = dr > 0 ? -1 : SIZE;
    const rStep  = dr > 0 ? -1 : 1;

    const cStart = dc > 0 ? SIZE-1 : 0;
    const cEnd   = dc > 0 ? -1 : SIZE;
    const cStep  = dc > 0 ? -1 : 1;

    for (let r = rStart; r !== rEnd; r += rStep) {
      for (let c = cStart; c !== cEnd; c += cStep) {
        if (!grid[r][c]) continue;
        let nr = r, nc = c;

        while (true) {
          const tr = nr + dr, tc = nc + dc;
          if (tr < 0 || tr >= SIZE || tc < 0 || tc >= SIZE) break;

          if (!grid[tr][tc]) {
            grid[tr][tc] = grid[nr][nc];
            grid[nr][nc] = 0;
            nr = tr; nc = tc;
            moved = true;
          } else if (grid[tr][tc] === grid[nr][nc] && !merged[tr][tc]) {
            grid[tr][tc] *= 2;
            score += grid[tr][tc];
            grid[nr][nc] = 0;
            merged[tr][tc] = true;
            moved = true;
            break;
          } else break;
        }
      }
    }

    if (!moved) { prev = null; return; }
    spawn();
    render();
    if (!canMove()) {
      // simple end state: start new game on next move button
    }
  }

  function undo(){
    if (!prev) return;
    grid = cloneGrid(prev.grid);
    score = prev.score;
    prev = null;
    render();
  }

  function newGame(){
    grid = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    score = 0;
    prev = null;
    spawn(); spawn();
    render();
  }

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft')  { e.preventDefault(); move(0,-1); }
    if (e.key === 'ArrowRight') { e.preventDefault(); move(0, 1); }
    if (e.key === 'ArrowUp')    { e.preventDefault(); move(-1,0); }
    if (e.key === 'ArrowDown')  { e.preventDefault(); move( 1,0); }
  }, {passive:false});

  // Touch (stop scroll + detect swipe)
  let start = null;

  boardEl.addEventListener('touchstart', (e) => {
    if (e.touches.length !== 1) return;
    start = {x: e.touches[0].clientX, y: e.touches[0].clientY};
  }, {passive:true});

  boardEl.addEventListener('touchmove', (e) => {
    // critical: prevent page from moving
    e.preventDefault();
  }, {passive:false});

  boardEl.addEventListener('touchend', (e) => {
    if (!start) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - start.x;
    const dy = t.clientY - start.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const TH = 28;
    if (Math.max(adx, ady) < TH) { start = null; return; }
    if (adx > ady) move(0, dx > 0 ? 1 : -1);
    else move(dy > 0 ? 1 : -1, 0);
    start = null;
  }, {passive:true});

  newBtn.addEventListener('click', newGame);
  undoBtn.addEventListener('click', undo);
  window.addEventListener('resize', () => render(), {passive:true});

  newGame();
})();
</script>
</body>
</html>
