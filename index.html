<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>2048</title>

<style>
:root{
  --bg:#faf8ef;
  --board:#bbada0;
  --empty:#cdc1b4;
  --text:#776e65;
  --light:#f9f6f2;

  --pad:10px;
  --gap:10px;
  --radius:12px;

  /* Animation feel (closer to original) */
  --moveDur: 180ms;
  --ease: cubic-bezier(.2,.8,.2,1);
  --spawnDur: 220ms;
  --mergeDur: 220ms;
}

*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  overscroll-behavior:none;
  background:var(--bg);
  font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,system-ui,sans-serif;
}
body{display:flex;justify-content:center}

.wrap{width:min(520px,100%);padding:16px}

.header{display:flex;justify-content:space-between;align-items:flex-end;gap:12px;flex-wrap:wrap}
h1{margin:0;font-size:48px;color:var(--text);letter-spacing:-1px}

.scoreRow{display:flex;gap:10px}
.scorebox{
  background:var(--board);
  color:var(--light);
  padding:8px 12px;
  border-radius:10px;
  text-align:center;
  min-width:92px;
}
.scorebox small{display:block;font-size:11px;font-weight:800;letter-spacing:.5px;opacity:.9}
.scorebox span{display:block;font-weight:900;font-size:18px;margin-top:2px}

.controls{margin:10px 0 12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
button{
  background:#8f7a66;border:none;color:#fff;
  padding:10px 14px;border-radius:10px;font-weight:900;
}
button:active{transform:translateY(1px)}

.board{
  background:var(--board);
  padding:var(--pad);
  border-radius:var(--radius);
  position:relative;
  width:100%;
  aspect-ratio:1/1;
  touch-action:none;
  user-select:none;
}

.grid{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  grid-template-rows:repeat(4,1fr);
  gap:var(--gap);
  width:100%;
  height:100%;
}

.cell{background:var(--empty);border-radius:12px}

/* tile layer shares SAME box as grid (inside padding) */
.tile-layer{
  position:absolute;
  inset:var(--pad);
  pointer-events:none;
}

.tile{
  position:absolute;
  transition:transform var(--moveDur) var(--ease);
  will-change:transform;
}

/* inner element handles scale animations so movement translate stays clean */
.tile-inner{
  width:100%;
  height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  border-radius:12px;
  transform:scale(1);
}

/* Spawn + merge animations (original-like) */
@keyframes popIn {
  0%   { transform:scale(0); }
  55%  { transform:scale(1.08); }
  100% { transform:scale(1); }
}
@keyframes popMerge {
  0%   { transform:scale(1); }
  40%  { transform:scale(1.12); }
  100% { transform:scale(1); }
}
.tile.spawn .tile-inner{ animation: popIn var(--spawnDur) var(--ease) both; }
.tile.merge .tile-inner{ animation: popMerge var(--mergeDur) var(--ease) both; }

/* colors */
.v2{background:#eee4da;color:var(--text)}
.v4{background:#ede0c8;color:var(--text)}
.v8{background:#f2b179;color:white}
.v16{background:#f59563;color:white}
.v32{background:#f67c5f;color:white}
.v64{background:#f65e3b;color:white}
.v128{background:#edcf72;color:white}
.v256{background:#edcc61;color:white}
.v512{background:#edc850;color:white}
.v1024{background:#edc53f;color:white}
.v2048{background:#edc22e;color:white}

/* Reduce motion accessibility */
@media (prefers-reduced-motion: reduce){
  :root{ --moveDur: 1ms; --spawnDur: 1ms; --mergeDur: 1ms; }
  .tile-inner{ animation:none !important; }
}
</style>
</head>

<body>
<div class="wrap">
  <div class="header">
    <h1>2048</h1>
    <div class="scoreRow">
      <div class="scorebox"><small>SCORE</small><span id="score">0</span></div>
      <div class="scorebox"><small>BEST</small><span id="best">0</span></div>
    </div>
  </div>

  <div class="controls">
    <button id="newBtn">Neu</button>
    <button id="undoBtn">Undo</button>
  </div>

  <div class="board" id="board">
    <div class="grid" id="grid" aria-hidden="true">
      <div class="cell" data-r="0" data-c="0"></div><div class="cell" data-r="0" data-c="1"></div><div class="cell" data-r="0" data-c="2"></div><div class="cell" data-r="0" data-c="3"></div>
      <div class="cell" data-r="1" data-c="0"></div><div class="cell" data-r="1" data-c="1"></div><div class="cell" data-r="1" data-c="2"></div><div class="cell" data-r="1" data-c="3"></div>
      <div class="cell" data-r="2" data-c="0"></div><div class="cell" data-r="2" data-c="1"></div><div class="cell" data-r="2" data-c="2"></div><div class="cell" data-r="2" data-c="3"></div>
      <div class="cell" data-r="3" data-c="0"></div><div class="cell" data-r="3" data-c="1"></div><div class="cell" data-r="3" data-c="2"></div><div class="cell" data-r="3" data-c="3"></div>
    </div>
    <div class="tile-layer" id="tiles"></div>
  </div>
</div>

<script>
(() => {
  const SIZE = 4;
  const boardEl = document.getElementById('board');
  const gridEl  = document.getElementById('grid');
  const layer   = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const newBtn  = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');

  let grid, score = 0;
  let best = Number(localStorage.getItem('best2048') || 0) || 0;
  bestEl.textContent = best;

  let prev = null; // {grid, score}

  // Animation markers for next render
  let lastSpawn = null; // {r,c,v}
  let lastMerges = [];  // [{r,c,v}]

  function cloneGrid(g){ return g.map(r => r.slice()); }

  // Measure real background cell positions => perfect alignment on all devices
  let cellPos = Array.from({length: SIZE}, () => Array.from({length: SIZE}, () => ({x:0,y:0,w:0,h:0})));

  function measureCells(){
    const gridRect = gridEl.getBoundingClientRect();
    const cells = gridEl.querySelectorAll('.cell');
    cells.forEach(cell => {
      const r = Number(cell.dataset.r), c = Number(cell.dataset.c);
      const rect = cell.getBoundingClientRect();
      cellPos[r][c] = {
        x: rect.left - gridRect.left,
        y: rect.top  - gridRect.top,
        w: rect.width,
        h: rect.height
      };
    });
  }

  function spawn() {
    const empty = [];
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) empty.push([r,c]);
    if (!empty.length) return false;
    const [r,c] = empty[(Math.random() * empty.length) | 0];
    const v = Math.random() < 0.9 ? 2 : 4;
    grid[r][c] = v;
    lastSpawn = {r,c,v};
    return true;
  }

  function fontSizeFor(value, cellW){
    const d = String(value).length;
    if (d <= 2) return cellW / 2.4;
    if (d === 3) return cellW / 2.8;
    if (d === 4) return cellW / 3.25;
    return cellW / 3.7;
  }

  function isMarkedSpawn(r,c,v){
    return lastSpawn && lastSpawn.r===r && lastSpawn.c===c && lastSpawn.v===v;
  }
  function isMarkedMerge(r,c,v){
    return lastMerges.some(m => m.r===r && m.c===c && m.v===v);
  }

  function render() {
    measureCells();
    layer.innerHTML = '';

    scoreEl.textContent = score;
    if (score > best) {
      best = score;
      localStorage.setItem('best2048', String(best));
      bestEl.textContent = best;
    }

    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const v = grid[r][c];
        if (!v) continue;

        const p = cellPos[r][c];

        const tile = document.createElement('div');
        tile.className = 'tile';
        if (isMarkedSpawn(r,c,v)) tile.classList.add('spawn');
        if (isMarkedMerge(r,c,v)) tile.classList.add('merge');

        tile.style.width  = p.w + 'px';
        tile.style.height = p.h + 'px';
        tile.style.transform = `translate3d(${p.x}px, ${p.y}px, 0)`;

        const inner = document.createElement('div');
        inner.className = 'tile-inner v' + v;
        inner.textContent = v;
        inner.style.fontSize = fontSizeFor(v, p.w) + 'px';

        tile.appendChild(inner);
        layer.appendChild(tile);
      }
    }

    // Clear markers after paint (so they only animate once)
    lastSpawn = null;
    lastMerges = [];
  }

  function canMove() {
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) return true;
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const v = grid[r][c];
        if (r+1<SIZE && grid[r+1][c] === v) return true;
        if (c+1<SIZE && grid[r][c+1] === v) return true;
      }
    }
    return false;
  }

  function move(dr, dc) {
    prev = { grid: cloneGrid(grid), score };
    lastMerges = [];

    let moved = false;
    const merged = Array.from({length: SIZE}, () => Array(SIZE).fill(false));

    const rStart = dr > 0 ? SIZE-1 : 0;
    const rEnd   = dr > 0 ? -1 : SIZE;
    const rStep  = dr > 0 ? -1 : 1;

    const cStart = dc > 0 ? SIZE-1 : 0;
    const cEnd   = dc > 0 ? -1 : SIZE;
    const cStep  = dc > 0 ? -1 : 1;

    for (let r = rStart; r !== rEnd; r += rStep) {
      for (let c = cStart; c !== cEnd; c += cStep) {
        if (!grid[r][c]) continue;
        let nr = r, nc = c;

        while (true) {
          const tr = nr + dr, tc = nc + dc;
          if (tr < 0 || tr >= SIZE || tc < 0 || tc >= SIZE) break;

          if (!grid[tr][tc]) {
            grid[tr][tc] = grid[nr][nc];
            grid[nr][nc] = 0;
            nr = tr; nc = tc;
            moved = true;
          } else if (grid[tr][tc] === grid[nr][nc] && !merged[tr][tc]) {
            grid[tr][tc] *= 2;
            score += grid[tr][tc];
            grid[nr][nc] = 0;
            merged[tr][tc] = true;
            lastMerges.push({r: tr, c: tc, v: grid[tr][tc]});
            moved = true;
            break;
          } else break;
        }
      }
    }

    if (!moved) { prev = null; lastMerges = []; return; }
    spawn();
    render();
    if (!canMove()) {
      // end state not shown
    }
  }

  function undo(){
    if (!prev) return;
    grid = cloneGrid(prev.grid);
    score = prev.score;
    prev = null;
    lastSpawn = null;
    lastMerges = [];
    render();
  }

  function newGame(){
    grid = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    score = 0;
    prev = null;
    lastSpawn = null;
    lastMerges = [];
    spawn(); spawn();
    render();
  }

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft')  { e.preventDefault(); move(0,-1); }
    if (e.key === 'ArrowRight') { e.preventDefault(); move(0, 1); }
    if (e.key === 'ArrowUp')    { e.preventDefault(); move(-1,0); }
    if (e.key === 'ArrowDown')  { e.preventDefault(); move( 1,0); }
  }, {passive:false});

  // Touch: block scroll and detect swipe
  let start = null;

  boardEl.addEventListener('touchstart', (e) => {
    if (e.touches.length !== 1) return;
    start = {x: e.touches[0].clientX, y: e.touches[0].clientY};
  }, {passive:true});

  boardEl.addEventListener('touchmove', (e) => {
    e.preventDefault();
  }, {passive:false});

  boardEl.addEventListener('touchend', (e) => {
    if (!start) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - start.x;
    const dy = t.clientY - start.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const TH = 28;
    if (Math.max(adx, ady) < TH) { start = null; return; }
    if (adx > ady) move(0, dx > 0 ? 1 : -1);
    else move(dy > 0 ? 1 : -1, 0);
    start = null;
  }, {passive:true});

  newBtn.addEventListener('click', newGame);
  undoBtn.addEventListener('click', undo);

  // Re-measure precisely on resize/orientation/font load
  window.addEventListener('resize', () => render(), {passive:true});
  window.addEventListener('orientationchange', () => setTimeout(render, 50), {passive:true});

  // Initial
  newGame();
})();
</script>
</body>
</html>
