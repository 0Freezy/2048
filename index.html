<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>2048 (Mobile)</title>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="2048">

  <style>
    :root{
      --bg:#faf8ef; --panel:#bbada0; --empty:#cdc1b4;
      --text:#776e65; --textLight:#f9f6f2;
      --gap:10px; --radius:14px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg); color:var(--text);
      display:flex; justify-content:center;
    }
    .wrap{ width:min(520px, 100%); padding:16px 16px 28px; }
    header{ display:flex; align-items:flex-end; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    h1{ margin:0; font-size:54px; line-height:1; letter-spacing:-1px; }
    .scores{ display:flex; gap:10px; }
    .scoreBox{
      background:#bbada0; color:#f9f6f2;
      border-radius:10px; padding:8px 12px; min-width:90px; text-align:center;
      font-weight:700;
    }
    .scoreBox small{ display:block; font-weight:800; opacity:.85; font-size:12px; letter-spacing:.6px; }
    .scoreBox span{ display:block; font-size:20px; margin-top:2px; }
    .sub{
      margin:10px 0 14px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      align-items:center;
    }
    .hint{ font-size:14px; opacity:.85; }
    .btns{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      border:0; border-radius:10px; padding:10px 12px;
      background:#8f7a66; color:#f9f6f2; font-weight:800;
      cursor:pointer;
    }
    button:active{ transform:translateY(1px); }

    .board{
      position:relative;
      background:var(--panel);
      border-radius:var(--radius);
      padding:var(--gap);
      aspect-ratio:1/1;
      width:100%;
      touch-action:none;
      user-select:none;
    }

    /* background grid */
    .grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);   /* FIX: rows lock */
      gap:var(--gap);
      width:100%; height:100%;
    }
    .cell{ background:var(--empty); border-radius:12px; }

    /* Foreground tile layer (absolute positioning for slide animation) */
    .tiles{
      position:absolute;
      inset:var(--gap);
      pointer-events:none;
    }

    .tile{
      position:absolute;
      display:flex; align-items:center; justify-content:center;
      border-radius:12px;
      font-weight:900;
      color:var(--text);
      width: var(--cell, 60px);
      height: var(--cell, 60px);
      transform: translate3d(0,0,0);
      transition: transform 120ms ease-in-out;
      will-change: transform;
    }

    .tile.appear{ animation: popIn 140ms ease-out; }
    .tile.merge { animation: popMerge 160ms ease-out; }

    @keyframes popIn {
      0% { transform: translate3d(var(--x,0), var(--y,0), 0) scale(0.6); }
      100% { transform: translate3d(var(--x,0), var(--y,0), 0) scale(1); }
    }
    @keyframes popMerge {
      0% { transform: translate3d(var(--x,0), var(--y,0), 0) scale(1); }
      50% { transform: translate3d(var(--x,0), var(--y,0), 0) scale(1.10); }
      100% { transform: translate3d(var(--x,0), var(--y,0), 0) scale(1); }
    }

    /* overlay */
    .overlay{
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      background:rgba(238,228,218,.78);
      border-radius:var(--radius);
      text-align:center;
      padding:20px;
    }
    .overlay.show{ display:flex; }
    .overlay h2{ margin:0 0 10px; font-size:42px; }
    .overlay p{ margin:0 0 14px; font-weight:700; }
    .overlay .btns{ justify-content:center; }

    footer{ margin-top:10px; font-size:12px; opacity:.75; line-height:1.4; }

    /* tile colors + font scaling */
    .v2{ background:#eee4da; }
    .v4{ background:#ede0c8; }
    .v8{ background:#f2b179; color:var(--textLight); }
    .v16{ background:#f59563; color:var(--textLight); }
    .v32{ background:#f67c5f; color:var(--textLight); }
    .v64{ background:#f65e3b; color:var(--textLight); }
    .v128{ background:#edcf72; color:var(--textLight); }
    .v256{ background:#edcc61; color:var(--textLight); }
    .v512{ background:#edc850; color:var(--textLight); }
    .v1024{ background:#edc53f; color:var(--textLight); }
    .v2048{ background:#edc22e; color:var(--textLight); }
    .v4096,.v8192,.v16384{ background:#3c3a32; color:var(--textLight); }

    /* responsive base font size in tiles */
    .tile[data-digits="1"]{ font-size:34px; }
    .tile[data-digits="2"]{ font-size:34px; }
    .tile[data-digits="3"]{ font-size:30px; }
    .tile[data-digits="4"]{ font-size:26px; }
    .tile[data-digits="5"]{ font-size:22px; }

    @media (max-width:420px){
      h1{ font-size:44px; }
      .tile[data-digits="1"], .tile[data-digits="2"]{ font-size:30px; }
      .tile[data-digits="3"]{ font-size:26px; }
      .tile[data-digits="4"]{ font-size:22px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>2048</h1>
      <div class="scores">
        <div class="scoreBox"><small>SCORE</small><span id="score">0</span></div>
        <div class="scoreBox"><small>BEST</small><span id="best">0</span></div>
      </div>
    </header>

    <div class="sub">
      <div class="hint">Swipe oder Pfeiltasten. <b>Undo</b> geht 1 Zug zurück.</div>
      <div class="btns">
        <button id="newBtn">Neu</button>
        <button id="undoBtn">Undo</button>
      </div>
    </div>

    <div class="board" id="board" aria-label="2048 Spielfeld">
      <div class="grid" aria-hidden="true">
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      </div>
      <div class="tiles" id="tiles"></div>

      <div class="overlay" id="overlay">
        <div>
          <h2 id="overlayTitle">Game Over</h2>
          <p id="overlayText"></p>
          <div class="btns">
            <button id="keepBtn">Weiterspielen</button>
            <button id="restartBtn">Neu starten</button>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Tipp: Wenn du es als App willst: In Safari → Teilen → „Zum Home-Bildschirm“.
    </footer>
  </div>

<script>
(() => {
  const SIZE = 4;
  const GAP = 10; // must match --gap (px)
  const tilesEl = document.getElementById('tiles');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayText  = document.getElementById('overlayText');
  const newBtn = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');
  const restartBtn = document.getElementById('restartBtn');
  const keepBtn = document.getElementById('keepBtn');
  const boardEl = document.getElementById('board');

  let best = loadBest();

  /** State includes tile IDs so we can animate movement */
  let state = null;
  let prevState = null;
  let keepPlaying = false;

  let idCounter = 1;

  function loadBest() {
    const v = Number(localStorage.getItem('best2048') || 0);
    return Number.isFinite(v) ? v : 0;
  }
  function saveBest(v) { localStorage.setItem('best2048', String(v)); }

  function emptyState(){
    return {
      score: 0,
      won: false,
      grid: Array.from({length: SIZE}, () => Array(SIZE).fill(null)), // stores tileId or null
      tiles: new Map(), // tileId -> {id,value,r,c}
    };
  }

  function cloneState(s){
    const ns = {
      score: s.score,
      won: s.won,
      grid: s.grid.map(row => row.slice()),
      tiles: new Map(),
    };
    for (const [id,t] of s.tiles.entries()){
      ns.tiles.set(id, {...t});
    }
    return ns;
  }

  function computeCell(){
    const w = tilesEl.clientWidth; // tiles layer inset already
    const cell = Math.floor((w - GAP * (SIZE-1)) / SIZE);
    tilesEl.style.setProperty('--cell', cell + 'px');
    return cell;
  }

  function posFor(r,c,cell){
    const x = c * (cell + GAP);
    const y = r * (cell + GAP);
    return {x,y};
  }

  function spawnRandom(s){
    const empties = [];
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        if (!s.grid[r][c]) empties.push([r,c]);
      }
    }
    if (!empties.length) return null;
    const [r,c] = empties[(Math.random()*empties.length)|0];
    const value = Math.random() < 0.9 ? 2 : 4;
    const id = String(idCounter++);
    const tile = {id, value, r, c};
    s.tiles.set(id, tile);
    s.grid[r][c] = id;
    return id;
  }

  function digits(n){ return String(n).length; }

  function tileClass(v){
    if (v >= 16384) return 'v16384';
    if (v >= 8192) return 'v8192';
    if (v >= 4096) return 'v4096';
    return 'v' + v;
  }

  function canMove(s){
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!s.grid[r][c]) return true;
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const id = s.grid[r][c];
        const v = s.tiles.get(id).value;
        if (r+1<SIZE){
          const id2 = s.grid[r+1][c];
          if (id2 && s.tiles.get(id2).value === v) return true;
        }
        if (c+1<SIZE){
          const id2 = s.grid[r][c+1];
          if (id2 && s.tiles.get(id2).value === v) return true;
        }
      }
    }
    return false;
  }

  function showOverlay(type){
    overlay.classList.add('show');
    if (type === 'won'){
      overlayTitle.textContent = 'Du hast 2048!';
      overlayText.textContent = 'Du kannst weiter spielen oder neu starten.';
      keepBtn.style.display = '';
    } else {
      overlayTitle.textContent = 'Game Over';
      overlayText.textContent = 'Keine Züge mehr möglich.';
      keepBtn.style.display = 'none';
    }
  }
  function hideOverlay(){ overlay.classList.remove('show'); }

  /** Movement & merge preserving IDs for animation (like original) */
  function move(dir){
    if (overlay.classList.contains('show') && !keepPlaying) return;

    const s = cloneState(state);
    prevState = cloneState(state);

    const mergedIdsToRemove = new Set();
    const newTilesToAppear = new Set();
    const mergedNewIds = new Set();

    const delta = {
      left:  {dr:0, dc:-1},
      right: {dr:0, dc: 1},
      up:    {dr:-1,dc: 0},
      down:  {dr: 1,dc: 0},
    }[dir];

    // traversal lines
    function lineCells(index){
      const cells = [];
      if (dir === 'left' || dir === 'right'){
        const r = index;
        for (let c=0;c<SIZE;c++) cells.push([r,c]);
        if (dir === 'right') cells.reverse();
      } else {
        const c = index;
        for (let r=0;r<SIZE;r++) cells.push([r,c]);
        if (dir === 'down') cells.reverse();
      }
      return cells;
    }

    let moved = false;
    let gained = 0;

    // Clear grid (we'll rebuild)
    s.grid = Array.from({length: SIZE}, () => Array(SIZE).fill(null));

    for (let i=0;i<SIZE;i++){
      const cells = lineCells(i);
      const lineIds = [];
      for (const [r,c] of cells){
        const id = state.grid[r][c];
        if (id) lineIds.push(id);
      }

      const out = [];
      let k = 0;
      while (k < lineIds.length){
        const id1 = lineIds[k];
        const t1 = state.tiles.get(id1);
        if (k+1 < lineIds.length){
          const id2 = lineIds[k+1];
          const t2 = state.tiles.get(id2);
          if (t1.value === t2.value){
            // merge: create new tile id at next out position
            const newId = String(idCounter++);
            const newVal = t1.value * 2;
            gained += newVal;

            mergedIdsToRemove.add(id1);
            mergedIdsToRemove.add(id2);

            const outPosIndex = out.length;
            const [rr,cc] = cells[outPosIndex];
            const nt = {id:newId, value:newVal, r:rr, c:cc};
            s.tiles.set(newId, nt);
            out.push(newId);
            mergedNewIds.add(newId);

            k += 2;
            continue;
          }
        }
        // no merge
        out.push(id1);
        k += 1;
      }

      // place out ids into new grid and update their positions
      for (let j=0;j<SIZE;j++){
        const [r,c] = cells[j];
        const id = out[j] || null;
        if (id){
          // if old tile kept, update position
          if (s.tiles.has(id) && !mergedNewIds.has(id)){
            // it is an existing tile from previous state; take it from prev state's tile data
            const ot = state.tiles.get(id);
            s.tiles.set(id, {...ot, r, c});
          } else if (!s.tiles.has(id)) {
            // should not happen
          } else {
            // merged tile already positioned
          }
          s.grid[r][c] = id;
        }
      }
    }

    // Remove merged source tiles
    for (const id of mergedIdsToRemove){
      s.tiles.delete(id);
    }

    // Detect move (compare grids)
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        if (state.grid[r][c] !== s.grid[r][c]) { moved = true; break; }
      }
      if (moved) break;
    }

    if (!moved) return;

    s.score += gained;

    // win check
    if (!state.won){
      for (const t of s.tiles.values()){
        if (t.value === 2048){
          s.won = true;
          keepPlaying = false;
          showOverlay('won');
          break;
        }
      }
    }

    // spawn new tile
    const spawnedId = spawnRandom(s);
    if (spawnedId) newTilesToAppear.add(spawnedId);

    // update best
    if (s.score > best){
      best = s.score;
      saveBest(best);
    }

    // apply new state
    state = s;

    // render with animation hints
    render({appear:newTilesToAppear, merge:mergedNewIds});

    // game over?
    if (!canMove(state) && (!state.won || keepPlaying)){
      keepPlaying = false;
      showOverlay('over');
    }
  }

  /** DOM / Animation render */
  const domTiles = new Map(); // id -> element

  function render(anim = {appear:new Set(), merge:new Set()}){
    const cell = computeCell();

    // update score UI
    scoreEl.textContent = state.score;
    bestEl.textContent = best;

    // create/update tiles
    for (const [id,t] of state.tiles.entries()){
      let el = domTiles.get(id);
      if (!el){
        el = document.createElement('div');
        el.className = 'tile';
        el.dataset.id = id;
        tilesEl.appendChild(el);
        domTiles.set(id, el);
      }
      el.textContent = t.value;
      el.classList.remove('appear','merge');
      el.classList.remove(...Array.from(el.classList).filter(c => c.startsWith('v')));
      el.classList.add(tileClass(t.value));
      el.dataset.digits = String(digits(t.value));

      const {x,y} = posFor(t.r, t.c, cell);
      el.style.setProperty('--x', x + 'px');
      el.style.setProperty('--y', y + 'px');
      el.style.transform = `translate3d(${x}px, ${y}px, 0)`;

      if (anim.appear.has(id)) el.classList.add('appear');
      if (anim.merge.has(id)) el.classList.add('merge');
    }

    // remove tiles that no longer exist
    for (const [id,el] of domTiles.entries()){
      if (!state.tiles.has(id)){
        // fade out quickly
        el.style.transition = 'opacity 80ms ease';
        el.style.opacity = '0';
        setTimeout(() => {
          el.remove();
          domTiles.delete(id);
        }, 90);
      } else {
        el.style.opacity = '1';
        el.style.transition = 'transform 120ms ease-in-out';
      }
    }
  }

  function undo(){
    if (!prevState) return;
    state = cloneState(prevState);
    prevState = null;
    hideOverlay();
    render({appear:new Set(), merge:new Set()});
  }

  function newGame(){
    state = emptyState();
    prevState = null;
    keepPlaying = false;
    hideOverlay();
    spawnRandom(state);
    spawnRandom(state);
    render({appear:new Set(state.tiles.keys()), merge:new Set()});
  }

  // controls
  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (k === 'ArrowLeft') { e.preventDefault(); move('left'); }
    else if (k === 'ArrowRight') { e.preventDefault(); move('right'); }
    else if (k === 'ArrowUp') { e.preventDefault(); move('up'); }
    else if (k === 'ArrowDown') { e.preventDefault(); move('down'); }
    else if (k.toLowerCase() === 'u') { undo(); }
    else if (k.toLowerCase() === 'r') { newGame(); }
  }, {passive:false});

  // touch swipe
  let touchStart = null;
  boardEl.addEventListener('touchstart', (e) => {
    if (!e.touches || e.touches.length !== 1) return;
    const t = e.touches[0];
    touchStart = {x: t.clientX, y: t.clientY};
  }, {passive:true});

  boardEl.addEventListener('touchmove', (e) => { e.preventDefault(); }, {passive:false});

  boardEl.addEventListener('touchend', (e) => {
    if (!touchStart) return;
    const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
    if (!t) return;
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const THRESH = 28;
    if (Math.max(adx, ady) < THRESH) { touchStart = null; return; }
    if (adx > ady) move(dx > 0 ? 'right' : 'left');
    else move(dy > 0 ? 'down' : 'up');
    touchStart = null;
  }, {passive:true});

  newBtn.addEventListener('click', newGame);
  undoBtn.addEventListener('click', undo);
  restartBtn.addEventListener('click', newGame);
  keepBtn.addEventListener('click', () => { keepPlaying = true; hideOverlay(); });

  // keep layout stable on rotate/resizes
  window.addEventListener('resize', () => render({appear:new Set(), merge:new Set()}), {passive:true});

  newGame();
})();
</script>
</body>
</html>
